from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from bs4 import BeautifulSoup
from urllib.request import urlopen
import subprocess
import builtwith
import json
import requests
import certifi
import ssl

@csrf_exempt
def final_scan(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body.decode('utf-8'))
            domain = data.get('domain')
            
            # Check if domain is None
            if domain is None:
                raise ValueError("Domain is missing in the request.", status=400)
            
            ## check tech stack
            tech_stack_result = get_tech_stack(domain)
            
            ## check subdomain
            subdomains = get_subdomains(domain)
            
            ## check header
            get_header_info = get_info_header(domain)
            
            return JsonResponse({'status': 'success', 'stack': tech_stack_result, 'subdomain': subdomains, 'header': get_header_info}, status=200)
            
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)
            
def get_tech_stack(domain):
    try:    
        result = builtwith.builtwith(f'https://{domain}')
        return result
    except Exception as e:
        return {'status': 'error', 'message': str(e)}
        
def get_info_header(domain):
    try:
        result = subprocess.check_output(['python3', './securityheaders/securityheaders.py', domain], text=True, stderr=subprocess.STDOUT)
        # Split the result by lines
        result_lines = result.split('\n')

        # Initialize a dictionary to store header information
        header_info = {}

        # Extract headers and their values
        for line in result_lines:
            if 'Header' in line:
                parts = line.split(' ... ')
                header = parts[0].replace("Header '", '').strip().replace('is missing', '').replace('contains value', '').replace("' ", '')
                status = 'OK' in parts[1]
                header_info[header] = status

        return header_info
    except Exception as e:
        return {"status": "error", "message": str(e)}
    
def get_subdomains(domain):
    try:
        # Run Sublist3r to enumerate subdomains
        subprocess.run(['sublist3r', '-d', domain, '-o', 'subdomains.txt'], check=True)

        # Read the subdomains from the file
        with open("subdomains.txt", "r") as file:
            subdomains = file.read().splitlines()

        # Return the subdomains as a JSON response
        return subdomains

    except Exception as e:
        return {"status": "error", "message": str(e)}

# def get_header_fail(domain):
#     try:
#         api_url = f'https://securityheaders.com/?q={domain}&followRedirects=on'
#         res = requests.get(api_url)
        
#         if res.status_code == 200:
#             soup = BeautifulSoup(res.text, 'html.parser')
#             td_table_cell = soup.find('tbody')

#             if td_table_cell:
#                 # Extract text content from td.tableCell
#                 text_content = td_table_cell.get_text(separator='\n')

#                 # Extract only the Headers section and remove leading/trailing whitespaces
#                 headers_section = text_content[text_content.find('Headers:'):]
#                 headers_section = headers_section.replace('\n', '').strip()

#                 return {"status": "success", "headers": headers_section}
#             else:
#                 return {"status": "error", "message": "Element 'td.tableCell' not found in the HTML."}
#         else:
#             return {"status": "error", "message": f"Request failed with status code {res.status_code}"}
#     except Exception as e:    
#         return {"status": "error", "message": str(e)}

# def get_ssl_certificate(request):
#     if request.method == 'POST':
#         try:
#             data = json.loads(request.body.decode('utf-8'))
#             domain = data.get('domain')
#             # url = f'https//{domain}'
            
#             context = ssl.create_default_context(cafile=certifi.where())
#             with urlopen(f'https://{domain}', context=context) as response:
#                 cert = response.info()["ssl_peer_certificate"]
#                 ssl_result = cert         
            
#             return JsonResponse({'status': 'success', 'ssl_certificate': ssl_result})
#         except Exception as e:
#             return JsonResponse({'status': 'error', 'message': str(e)}, status=500)