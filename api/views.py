from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime
import subprocess
import builtwith
import json
import requests
import ssl
import socket
import os


@csrf_exempt
def final_scan(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body.decode('utf-8'))
            domain = data.get('domain')
            
            # Check if domain is None
            if domain is None:
                raise ValueError("Domain is missing in the request.", status=400)
            
            scanner =  WebsiteScanner(domain)
            result = scanner.scan_website()
            
            return JsonResponse(result, status=200)
            
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

class WebsiteScanner:
    def __init__(self, domain):
        self.domain = domain
        
    def scan_website(self):
        try: 
            # ## check tech stack
            tech_stack_result = self.get_tech_stack()
            
            ## check subdomain
            subdomains = self.get_subdomains()
            
            ## check header
            get_header_info = self.get_info_header()
            
            ## check file identified
            directories_result = self.get_identified_files()
            
            ## chekc ssl certificate
            ssl_certif = self.get_ssl_cerfiticate_status()
            
            return{
                'status': 'success',
                'stack': tech_stack_result,
                'subdomain': subdomains,
                'header': get_header_info,
                'directories_found': directories_result,
                'ssl': ssl_certif
            }
            
        except Exception as e:
            return{
                'status': 'error',
                'message': str(e)
            }
                           
    def get_tech_stack(self):
        try:    
            result = builtwith.builtwith(f'https://{self.domain}')
            return result
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def get_info_header(self):
        try:
    
            BASE_DIR = os.path.dirname(os.path.abspath(__file__))
            command = f'python ./securityheaders/securityheaders.py {self.domain}'
            result = subprocess.check_output([command], text=True, stderr=subprocess.STDOUT, cwd=os.path.join(BASE_DIR, 'securityheaders'))
            
            # Split the result by lines
            result_lines = result.split('\n')

            # Initialize a dictionary to store header information
            header_info = {}

            # Extract headers and their values
            for line in result_lines:
                if 'Header' in line:
                    parts = line.split(' ... ')
                    header = parts[0].replace("Header '", '').strip().replace('is missing', '').replace('contains value', '').replace("' ", '')
                    status = 'OK' in parts[1]
                    header_info[header] = status

            return header_info
        except Exception as e:
            return {"status": "error", "message": str(e)}
        
    def get_subdomains(self):
        try:
            # Run Sublist3r to enumerate subdomains
            command = f'sublist3r -d {self.domain} -o subdomains.txt'
            subprocess.run([command], check=True, shell=True)

            # Read the subdomains from the file
            with open("subdomains.txt", "r") as file:
                subdomains = file.read().splitlines()

            # Return the subdomains as a JSON response
            return subdomains

        except Exception as e:
            return {"status": "error", "message": str(e)}

    def get_identified_files(self): 
        ## made variable storage
        data = {}
    
        try:
            ## check security.txt files
            security = requests.get(f'https://{self.domain}/security.txt')
            if security.status_code == 404:
                data['security.txt'] = 'Missing'
            else:
                data['security.txt'] = 'Identified'
                
            ## check robots.txt files
            robots = requests.get(f'https://{self.domain}/robots.txt')
            if robots.status_code == 404:
                data['robots.txt'] = 'Missing'
            else:
                data['robots.txt'] = 'Identified'
            
            ## check .well-known/security.txt files
            well_known_security = requests.get(f'https://{self.domain}/.well-known/security.txt')
            if well_known_security.status_code == 404:
                data['.well-known/security.txt'] = 'Missing'
            else:
                data['.well-known/security.txt'] = 'Identified'
            
            return data
        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_ssl_cerfiticate_status(self):
        try:
            ## check ssl
            context = ssl.create_default_context()
            
            with socket.create_connection((self.domain, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=self.domain) as ssock:
                    cert = ssock.getpeercert()
                    
                    ## get the string date
                    string_date = cert['notAfter']
                      
                    ## make format date      
                    format_date = "%b %d %H:%M:%S %Y %Z"
                    
                    ## integrate string and format
                    converted_date = datetime.strptime(string_date, format_date)                
                    
                    ## get current day
                    current_day = datetime.now()
                    
                    ## make expiration day
                    exp_day = (converted_date - current_day).days
                    
                    # Check if the certificate is not valid
                    if exp_day < 0:
                        return {'status': 'Certificate is not valid', 'exp_day': f'{exp_day} days'}
                    else:
                        return {'status': 'Certificate is valid', 'exp_day': f'{exp_day} days'}
        except Exception as e:
            return {'status': 'error', 'message': str(e)}